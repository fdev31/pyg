status: 200
content-length: 2673
content-transfer-encoding: binary
x-github-blob-mode: 100644
x-github-blob-sha: 80291392bb240cab0e0e0e283ad006e1bf4de0ae
x-github-blob-type: text/plain
x-content-type-options: nosniff
x-runtime: 991ms
etag: "b1cd1259bb4d0e3ff352ee02851cb45e"
cache-control: private
x-ratelimit-remaining: 100
x-github-blob-size: 2673
content-disposition: inline
set-cookie: _gh_sess=BAh7BzoRbG9jYWxlX2d1ZXNzMCIKZmxhc2hJQzonQWN0aW9uQ29udHJvbGxlcjo6Rmxhc2g6OkZsYXNoSGFzaHsABjoKQHVzZWR7AA%3D%3D--719def2ab2d99283383e374327fcdbb716c45c12;
 path=/; expires=Fri, 01 Jan 2021 00:00:00 GMT; secure; HttpOnly
-content-encoding: gzip
date: Mon, 09 May 2011 16:20:05 GMT
content-location: https://gist.github.com/raw/930964/badmo.py
strict-transport-security: max-age=2592000
server: nginx/0.7.67
connection: keep-alive
x-ratelimit-limit: 100
content-type: text/plain; charset=utf-8

import re
import os
import ast
import glob
import collections

class ImportVisitor(ast.NodeVisitor):
    def __init__(self):
        self.imports = []
        self.modules = collections.defaultdict(list)

    def visit_Import(self, node):
        for name in node.names:
            self.imports.append(name.asname or name.name)

    def visit_ImportFrom(self, node):
        for name in node.names:
            self.modules[node.module].append(name.asname or name.name)

def parse_string(code):
    visitor = ImportVisitor()
    visitor.visit(ast.parse(code))
    return visitor.imports, visitor.modules

def parse_file(name):
    with open(name) as f:
        code = f.read()
    return parse_string(code)

def check_file(path):
    i, m = parse_file(path)
    with open(path) as f:
        code = f.read()
    single_badmods = []
    badmods = collections.defaultdict(list)
    for mod in i:
        r = re.compile(r'{0}\.'.format(mod))
        if not r.search(code):
            single_badmods.append(mod)
    for mod, objs in m.iteritems():
        for obj in objs:
            if obj == '*':
                print 'Warning: importing all objects from {0}; cannot check'.format(mod)
                continue
            r = re.compile(r'{0}[\.|(]?'.format(obj))
            if len(r.findall(code)) < 2:
                badmods[mod].append(obj)
    return single_badmods, badmods

def format_result(filename, results):
    r1 = '\n'.join('\t{0} not used'.format(mod) for mod in results[0])
    r2 = '\n'.join('\t{0} not used (from {1})'.format(obj, package) for package, objs in results[1].iteritems() for obj in objs)
    if r1 or r2:
        result = '{0}:\n' \
                 '{1}\n' \
                 '{2}'.format(filename, r1 or '', r2 or '')
    elif not r1 and not r2:
        result = '{0}: OK'.format(filename)
    return result

def scan(path):
    return format_result(os.path.basename(path), check_file(path))


def main():
    import argparse
    parser = argparse.ArgumentParser(prog='badmo')
    parser.add_argument('-d', '--dir', default='.', metavar='<path>', help='Set the directory to scan')
    parser.add_argument('-f', '--file', metavar='<path>', help='Scan a single file only')
    args = parser.parse_args()

    if args.file:
        print 'Scanning {0}'.format(args.file)
        print scan(args.file)

    if args.dir != '.' or not args.file:
        files = []
        path = os.path.abspath(args.dir)
        files.extend(glob.glob(os.path.join(path, '*.py')))
        print ('\n' if args.file else '') + 'Scanning {0}'.format(path)

        for file in sorted(files):
            print scan(file)


if __name__ == '__main__':
    main()